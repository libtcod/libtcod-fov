#!/usr/bin/env python3
"""Writes out the source and include files needed for AutoTools.

This script will update the collected_files.md file.
"""

from __future__ import annotations

import os
import re
from os import PathLike
from pathlib import Path, PurePosixPath
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Iterable, Sequence

BANNER = "# This file was automatically generated by scripts/update_sources.py"


def get_sources(
    *,
    sources: bool = False,
    includes: bool = False,
    root: str | PathLike[str] = "src",
    directory: str | PathLike[str] = "src/libtcod-fov",
) -> Iterable[tuple[Path, Sequence[Path]]]:
    """Iterate over sources and headers with sub-folders grouped together."""
    re_inclusion = []
    if sources:
        re_inclusion.append("c|cpp")
    if includes:
        re_inclusion.append("h|hpp")
    re_valid = re.compile(rf""".*\.({"|".join(re_inclusion)})$""")

    for current_path_str, dirs, files_str in os.walk(directory):
        current_path = Path(current_path_str)
        # Ignore hidden directories.
        dirs[:] = [dir for dir in dirs if not dir.startswith(".")]  # noqa: A001
        files = [current_path / f for f in files_str if re_valid.match(f)]
        group = current_path.relative_to(root, walk_up=False)
        yield group, files


def all_sources(
    *,
    sources: bool = True,
    includes: bool = False,
) -> Iterable[Path]:
    """Iterate over all sources needed to compile libtcod."""
    for _, sources_ in get_sources(sources=sources, includes=includes):
        yield from sources_


def generate_am() -> str:
    """Returns an AutoMake script.

    This might be run on Windows, so it must return Unix file separators.
    """
    out = f"{BANNER}\n"
    for group_path, files_str in get_sources(
        sources=False, includes=True, root="include", directory="include/libtcod-fov"
    ):
        group_posix = PurePosixPath(group_path)
        include_name = str(group_posix).replace("/", "_").replace("-", "_")
        files = [str(PurePosixPath("../..", f)) for f in files_str]
        out += f"\n{include_name}_includedir = $(includedir)/{group_posix}"
        out += f"\n{include_name}_include_HEADERS = \\"
        out += "\n\t" + " \\\n\t".join(files)
        out += "\n"

    out += "\nlibtcod_fov_la_SOURCES = \\"
    out += "\n\t" + " \\\n\t".join(str(PurePosixPath("../..", f)) for f in all_sources())
    out += "\n"
    return out


def generate_cmake() -> str:
    """Returns a CMake script with libtcod's sources."""
    out = f"{BANNER}"
    out += "\ntarget_sources(${PROJECT_NAME} PRIVATE\n    "
    out += "\n    ".join(str(PurePosixPath(f.relative_to("src"))) for f in all_sources(includes=True))
    out += "\n)"
    for group_path, files in get_sources(sources=False, includes=True, root="include", directory="include"):
        group_posix = PurePosixPath(group_path)
        out += "\ninstall(FILES\n    "
        out += "\n    ".join(str(PurePosixPath(f.relative_to("src", walk_up=True))) for f in files)
        out += f"\n    DESTINATION ${{CMAKE_INSTALL_INCLUDEDIR}}/{group_posix}"
        out += "\n    COMPONENT IncludeFiles"
        out += "\n)"
    out += "\n"
    return out


def main() -> None:
    """Main script."""
    # Change to project root directory, using this file as a reference.
    os.chdir(Path(__file__, "../.."))

    Path("buildsys/autotools/sources.am").write_text(generate_am(), encoding="utf-8")
    Path("src/sources.cmake").write_text(generate_cmake(), encoding="utf-8")


if __name__ == "__main__":
    main()
